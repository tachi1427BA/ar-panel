<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR等身大キャラクターパネル</title>
    <!-- A-Frameを先に読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.0/aframe.min.js"></script>
    <!-- AR.jsを後に読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/AR.js/2.2.2/aframe-ar.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Helvetica', 'Arial', sans-serif;
            background: #000;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .control-group {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .control-group label {
            min-width: 60px;
            font-size: 14px;
            font-weight: bold;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="file"] {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            font-size: 14px;
        }

        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 12px 24px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            font-weight: bold;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 25px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .preset-images {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            overflow-x: auto;
            padding: 5px 0;
        }

        .preset-img {
            width: 60px;
            height: 80px;
            object-fit: cover;
            border-radius: 10px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .preset-img:hover, .preset-img.selected {
            border-color: #4CAF50;
            transform: scale(1.05);
        }

        #startButton {
            width: 100%;
            padding: 18px;
            font-size: 16px;
            background: linear-gradient(45deg, #2196F3, #1976D2);
            margin-top: 15px;
        }

        .hidden {
            display: none !important;
        }

        #errorMessage {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            display: none;
        }

        #loadingMessage {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            display: none;
            text-align: center;
        }

        .value-display {
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: #4CAF50;
        }

        h2 {
            margin: 0 0 15px 0;
            color: #4CAF50;
            text-align: center;
        }

        #info {
            font-size: 12px;
            color: #ccc;
            margin-top: 15px;
            line-height: 1.4;
        }

        /* A-Frame要素のスタイル */
        a-scene {
            height: 100vh;
            width: 100vw;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: white;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="loadingScreen" class="loading-screen">
        <div>ARを初期化中...</div>
    </div>

    <div id="ui">
        <h2>🎭 AR等身大キャラクターパネル</h2>
        <p>キャラクター画像をアップロードするか、プリセットから選択してください</p>
        
        <input type="file" id="imageInput" accept="image/*" />
        
        <div class="preset-images">
            <canvas class="preset-img" width="120" height="160" data-character="anime-girl"></canvas>
            <canvas class="preset-img" width="120" height="160" data-character="anime-boy"></canvas>
            <canvas class="preset-img" width="120" height="160" data-character="mascot"></canvas>
        </div>

        <div id="errorMessage"></div>
        <div id="loadingMessage"></div>
        
        <button id="startButton">🚀 ARを開始</button>
        
        <div id="info">
            📱 カメラの使用を許可してください<br>
            💡 明るい場所でご使用ください<br>
            🔄 デバイスを動かしてマーカーを探してください<br>
            📋 白い紙にマーカーを印刷すると効果的です
        </div>
    </div>

    <div id="controls" class="hidden">
        <div class="control-group">
            <label>📏 高さ:</label>
            <input type="range" id="heightSlider" min="50" max="200" value="100" />
            <span id="heightValue" class="value-display">100cm</span>
        </div>
        <div class="control-group">
            <label>📍 距離:</label>
            <input type="range" id="distanceSlider" min="1" max="10" value="3" step="0.5" />
            <span id="distanceValue" class="value-display">3.0m</span>
        </div>
        <div class="control-group">
            <label>🔄 回転:</label>
            <input type="range" id="rotationSlider" min="0" max="360" value="0" />
            <span id="rotationValue" class="value-display">0°</span>
        </div>
        <div class="control-group">
            <button id="resetButton">🔄 リセット</button>
            <button id="captureButton">📸 撮影</button>
            <button id="generateMarkerButton">🎯 マーカー生成</button>
            <button id="stopButton">⏹️ 終了</button>
        </div>
    </div>

    <!-- Hidden canvas for marker generation -->
    <canvas id="markerCanvas" width="512" height="512" style="display: none;"></canvas>

    <!-- A-Frame AR Scene -->
    <a-scene id="arScene" embedded arjs='sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;' 
             vr-mode-ui="enabled: false;" 
             renderer="logarithmicDepthBuffer: true;" 
             loading-screen="enabled: false"
             style="display: none;">
        
        <!-- Assets -->
        <a-assets>
            <img id="characterTexture" src="" crossorigin="anonymous">
        </a-assets>

        <!-- Marker -->
        <a-marker id="animatedmarker" type="pattern" url="" raycaster="objects: .clickable" emitevents="true">
            <!-- Character Plane -->
            <a-plane id="characterPlane" 
                     position="0 0.5 0" 
                     rotation="-90 0 0" 
                     width="0.6" 
                     height="1.0" 
                     material="src: #characterTexture; transparent: true; alphaTest: 0.1;"
                     animation="property: rotation; to: -90 360 0; loop: true; dur: 10000">
            </a-plane>
        </a-marker>

        <!-- Alternative: No-marker AR (requires HTTPS) -->
        <a-camera id="arCamera" gps-camera rotation-reader arjs-look-controls="smoothingFactor: 0.02">
            <!-- Fallback character for markerless mode -->
            <a-plane id="fallbackCharacter"
                     position="0 0 -3"
                     rotation="0 0 0"
                     width="0.6"
                     height="1.0"
                     material="src: #characterTexture; transparent: true; alphaTest: 0.1;"
                     visible="false">
            </a-plane>
        </a-camera>
    </a-scene>

    <script>
        class ARCharacterPanel {
            constructor() {
                this.scene = null;
                this.characterPlane = null;
                this.currentTextureUrl = null;
                this.isARStarted = false;
                this.selectedPreset = null;
                this.markerUrl = null;
                this.useMarkerlessMode = false;
                
                this.initializeApp();
            }

            async initializeApp() {
                try {
                    await this.waitForAFrame();
                    await this.initializePresetImages();
                    this.bindEvents();
                    this.hideLoading();
                    this.generateDefaultMarker();
                } catch (error) {
                    console.error('Initialization error:', error);
                    this.showError('初期化に失敗しました: ' + error.message);
                }
            }

            waitForAFrame() {
                return new Promise((resolve) => {
                    if (window.AFRAME) {
                        resolve();
                    } else {
                        window.addEventListener('load', resolve);
                    }
                });
            }

            async initializePresetImages() {
                const presets = document.querySelectorAll('.preset-img');
                
                await Promise.all([
                    this.createAnimeGirl(presets[0]),
                    this.createAnimeBoy(presets[1]),
                    this.createMascot(presets[2])
                ]);

                presets[0].onclick = () => this.selectPreset(presets[0]);
                presets[1].onclick = () => this.selectPreset(presets[1]);
                presets[2].onclick = () => this.selectPreset(presets[2]);

                this.selectPreset(presets[0]);
            }

            selectPreset(canvas) {
                if (this.selectedPreset) {
                    this.selectedPreset.classList.remove('selected');
                }
                
                canvas.classList.add('selected');
                this.selectedPreset = canvas;
                
                this.loadCanvasTexture(canvas);
            }

            loadCanvasTexture(canvas) {
                try {
                    const dataUrl = canvas.toDataURL('image/png');
                    this.setCharacterTexture(dataUrl);
                } catch (error) {
                    console.error('Texture loading error:', error);
                    this.showError('テクスチャの読み込みに失敗しました');
                }
            }

            setCharacterTexture(dataUrl) {
                this.currentTextureUrl = dataUrl;
                
                const textureElement = document.getElementById('characterTexture');
                if (textureElement) {
                    textureElement.src = dataUrl;
                    
                    // A-Frameのテクスチャを更新
                    textureElement.onload = () => {
                        const characterPlane = document.getElementById('characterPlane');
                        const fallbackCharacter = document.getElementById('fallbackCharacter');
                        
                        if (characterPlane) {
                            characterPlane.setAttribute('material', 'src', '#characterTexture');
                        }
                        if (fallbackCharacter) {
                            fallbackCharacter.setAttribute('material', 'src', '#characterTexture');
                        }
                    };
                }
            }

            async createAnimeGirl(canvas) {
                return new Promise(resolve => {
                    const ctx = canvas.getContext('2d');
                    
                    const gradient = ctx.createLinearGradient(0, 0, 0, 160);
                    gradient.addColorStop(0, '#FFB6C1');
                    gradient.addColorStop(0.5, '#FF91A4');
                    gradient.addColorStop(1, '#FF69B4');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 120, 160);
                    
                    this.drawCharacterBase(ctx, '#FFF8DC', '#8B4513', '#FF69B4');
                    
                    ctx.fillStyle = '#A0522D';
                    ctx.fillRect(35, 25, 50, 10);
                    
                    setTimeout(resolve, 10);
                });
            }

            async createAnimeBoy(canvas) {
                return new Promise(resolve => {
                    const ctx = canvas.getContext('2d');
                    
                    const gradient = ctx.createLinearGradient(0, 0, 0, 160);
                    gradient.addColorStop(0, '#87CEEB');
                    gradient.addColorStop(0.5, '#5F9FD3');
                    gradient.addColorStop(1, '#4169E1');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 120, 160);
                    
                    this.drawCharacterBase(ctx, '#FFF8DC', '#2F4F4F', '#4169E1');
                    
                    setTimeout(resolve, 10);
                });
            }

            async createMascot(canvas) {
                return new Promise(resolve => {
                    const ctx = canvas.getContext('2d');
                    
                    const gradient = ctx.createLinearGradient(0, 0, 0, 160);
                    gradient.addColorStop(0, '#98FB98');
                    gradient.addColorStop(0.5, '#7FE57F');
                    gradient.addColorStop(1, '#32CD32');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 120, 160);
                    
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(60, 60, 35, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(50, 50, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(70, 50, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(60, 65, 12, 0, Math.PI);
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#000';
                    ctx.stroke();
                    
                    ctx.fillStyle = '#32CD32';
                    ctx.beginPath();
                    ctx.arc(40, 35, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(80, 35, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    setTimeout(resolve, 10);
                });
            }

            drawCharacterBase(ctx, skinColor, hairColor, accentColor) {
                ctx.fillStyle = skinColor;
                ctx.fillRect(35, 30, 50, 60);
                
                ctx.fillStyle = '#000';
                ctx.fillRect(45, 45, 10, 10);
                ctx.fillRect(65, 45, 10, 10);
                
                ctx.fillStyle = '#FFF';
                ctx.fillRect(47, 47, 4, 4);
                ctx.fillRect(67, 47, 4, 4);
                
                ctx.fillStyle = accentColor;
                ctx.fillRect(55, 65, 10, 6);
                
                ctx.fillStyle = hairColor;
                ctx.fillRect(30, 20, 60, 25);
                
                ctx.fillStyle = accentColor;
                ctx.fillRect(40, 90, 40, 70);
            }

            bindEvents() {
                document.getElementById('imageInput').addEventListener('change', (e) => this.handleImageUpload(e));
                document.getElementById('startButton').addEventListener('click', () => this.startAR());
                document.getElementById('stopButton').addEventListener('click', () => this.stopAR());
                document.getElementById('resetButton').addEventListener('click', () => this.resetPosition());
                document.getElementById('captureButton').addEventListener('click', () => this.captureScreen());
                document.getElementById('generateMarkerButton').addEventListener('click', () => this.downloadMarker());
                
                document.getElementById('heightSlider').addEventListener('input', (e) => this.updateHeight(e.target.value));
                document.getElementById('distanceSlider').addEventListener('input', (e) => this.updateDistance(e.target.value));
                document.getElementById('rotationSlider').addEventListener('input', (e) => this.updateRotation(e.target.value));
            }

            handleImageUpload(event) {
                const file = event.target.files[0];
                if (file) {
                    if (this.selectedPreset) {
                        this.selectedPreset.classList.remove('selected');
                        this.selectedPreset = null;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.setCharacterTexture(e.target.result);
                    };
                    reader.onerror = () => {
                        this.showError('画像の読み込みに失敗しました');
                    };
                    reader.readAsDataURL(file);
                }
            }

            generateDefaultMarker() {
                const canvas = document.getElementById('markerCanvas');
                const ctx = canvas.getContext('2d');
                
                // 白背景
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 512, 512);
                
                // 黒枠
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, 512, 64);
                ctx.fillRect(0, 448, 512, 64);
                ctx.fillRect(0, 0, 64, 512);
                ctx.fillRect(448, 0, 64, 512);
                
                // 中央のパターン（3x3グリッド）
                const cellSize = 128;
                const startX = 128;
                const startY = 128;
                
                // シンプルなパターンを描画
                const pattern = [
                    [1, 0, 1],
                    [0, 1, 0],
                    [1, 0, 1]
                ];
                
                pattern.forEach((row, i) => {
                    row.forEach((cell, j) => {
                        if (cell) {
                            ctx.fillStyle = 'black';
                            ctx.fillRect(startX + j * cellSize, startY + i * cellSize, cellSize, cellSize);
                        }
                    });
                });
                
                this.markerUrl = canvas.toDataURL('image/png');
            }

            downloadMarker() {
                if (this.markerUrl) {
                    const link = document.createElement('a');
                    link.download = 'ar-marker.png';
                    link.href = this.markerUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    this.showMessage('マーカーをダウンロードしました！白い紙に印刷してご利用ください。');
                }
            }

            async startAR() {
                try {
                    this.hideError();
                    this.showLoading('ARを初期化中...');
                    
                    // カメラ権限を確認
                    await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment' }
                    });

                    // マーカーを設定
                    const marker = document.getElementById('animatedmarker');
                    if (this.markerUrl) {
                        marker.setAttribute('url', this.markerUrl);
                    }

                    // A-Frameシーンを表示
                    const scene = document.getElementById('arScene');
                    scene.style.display = 'block';
                    
                    // UIを切り替え
                    document.getElementById('ui').classList.add('hidden');
                    document.getElementById('controls').classList.remove('hidden');
                    
                    this.isARStarted = true;
                    this.hideLoading();

                    // マーカーレスモードの設定（HTTPS環境でのみ）
                    if (location.protocol === 'https:') {
                        setTimeout(() => {
                            this.enableMarkerlessMode();
                        }, 5000);
                    }
                    
                } catch (error) {
                    console.error('AR initialization failed:', error);
                    this.hideLoading();
                    this.showError('カメラのアクセスに失敗しました。HTTPS環境でお試しください。');
                }
            }

            enableMarkerlessMode() {
                const fallbackCharacter = document.getElementById('fallbackCharacter');
                if (fallbackCharacter) {
                    fallbackCharacter.setAttribute('visible', 'true');
                    this.useMarkerlessMode = true;
                    console.log('Markerless mode enabled');
                }
            }

            updateHeight(value) {
                document.getElementById('heightValue').textContent = value + 'cm';
                const scale = parseFloat(value) / 100;
                
                const characterPlane = document.getElementById('characterPlane');
                const fallbackCharacter = document.getElementById('fallbackCharacter');
                
                if (characterPlane) {
                    characterPlane.setAttribute('scale', `${scale} ${scale} ${scale}`);
                }
                if (fallbackCharacter) {
                    fallbackCharacter.setAttribute('scale', `${scale} ${scale} ${scale}`);
                }
            }

            updateDistance(value) {
                const distance = parseFloat(value);
                document.getElementById('distanceValue').textContent = distance.toFixed(1) + 'm';
                
                const fallbackCharacter = document.getElementById('fallbackCharacter');
                if (fallbackCharacter) {
                    fallbackCharacter.setAttribute('position', `0 0 -${distance}`);
                }
            }

            updateRotation(value) {
                document.getElementById('rotationValue').textContent = value + '°';
                const rotation = parseFloat(value);
                
                const characterPlane = document.getElementById('characterPlane');
                const fallbackCharacter = document.getElementById('fallbackCharacter');
                
                if (characterPlane) {
                    characterPlane.setAttribute('rotation', `-90 ${rotation} 0`);
                }
                if (fallbackCharacter) {
                    fallbackCharacter.setAttribute('rotation', `0 ${rotation} 0`);
                }
            }

            resetPosition() {
                document.getElementById('heightSlider').value = 100;
                document.getElementById('distanceSlider').value = 3;
                document.getElementById('rotationSlider').value = 0;
                this.updateHeight(100);
                this.updateDistance(3);
                this.updateRotation(0);
            }

            captureScreen() {
                if (this.isARStarted) {
                    try {
                        const scene = document.getElementById('arScene');
                        const canvas = scene.components.screenshot.getCanvas();
                        
                        if (canvas) {
                            const link = document.createElement('a');
                            link.download = 'ar-character-' + new Date().toISOString().slice(0, 19).replace(/:/g, '-') + '.png';
                            link.href = canvas.toDataURL('image/png');
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            
                            this.showMessage('スクリーンショットを保存しました');
                        } else {
                            throw new Error('Canvas not available');
                        }
                    } catch (error) {
                        console.error('Capture error:', error);
                        this.showError('スクリーンショットの保存に失敗しました');
                    }
                }
            }

            stopAR() {
                this.isARStarted = false;
                
                const scene = document.getElementById('arScene');
                scene.style.display = 'none';
                
                document.getElementById('ui').classList.remove('hidden');
                document.getElementById('controls').classList.add('hidden');
            }

            showError(message) {
                const errorDiv = document.getElementById('errorMessage');
                errorDiv.textContent = '❌ ' + message;
                errorDiv.style.display = 'block';
                setTimeout(() => this.hideError(), 5000);
            }

            hideError() {
                document.getElementById('errorMessage').style.display = 'none';
            }

            showLoading(message) {
                const loadingDiv = document.getElementById('loadingMessage');
                loadingDiv.textContent = '⏳ ' + message;
                loadingDiv.style.display = 'block';
            }

            hideLoading() {
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('loadingScreen').style.display = 'none';
            }

            showMessage(message) {
                this.showLoading(message);
                setTimeout(() => this.hideLoading(), 2000);
            }
        }

        // アプリケーション開始
        let arApp = null;
        document.addEventListener('DOMContentLoaded', () => {
            arApp = new ARCharacterPanel();
            window.arApp = arApp;
        });
    </script>
</body>
</html>