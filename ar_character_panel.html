<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARç­‰èº«å¤§ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‘ãƒãƒ«</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Helvetica', 'Arial', sans-serif;
            background: #000;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        #arContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .control-group {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .control-group label {
            min-width: 60px;
            font-size: 14px;
            font-weight: bold;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="file"] {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            font-size: 14px;
        }

        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 12px 24px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            font-weight: bold;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 25px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .preset-images {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            overflow-x: auto;
            padding: 5px 0;
        }

        .preset-img {
            width: 60px;
            height: 80px;
            object-fit: cover;
            border-radius: 10px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .preset-img:hover, .preset-img.selected {
            border-color: #4CAF50;
            transform: scale(1.05);
        }

        #info {
            font-size: 12px;
            color: #ccc;
            margin-top: 15px;
            line-height: 1.4;
        }

        #startButton {
            width: 100%;
            padding: 18px;
            font-size: 16px;
            background: linear-gradient(45deg, #2196F3, #1976D2);
            margin-top: 15px;
        }

        .hidden {
            display: none !important;
        }

        #errorMessage {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            display: none;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
        }

        #loadingMessage {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            display: none;
            text-align: center;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
        }

        .value-display {
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: #4CAF50;
        }

        h2 {
            margin: 0 0 15px 0;
            color: #4CAF50;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="arContainer">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
    </div>

    <div id="ui">
        <h2>ğŸ­ ARç­‰èº«å¤§ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‘ãƒãƒ«</h2>
        <p>ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‹ã€ãƒ—ãƒªã‚»ãƒƒãƒˆã‹ã‚‰é¸æŠã—ã¦ãã ã•ã„</p>
        
        <input type="file" id="imageInput" accept="image/*" />
        
        <div class="preset-images">
            <canvas class="preset-img" width="120" height="160" data-character="anime-girl"></canvas>
            <canvas class="preset-img" width="120" height="160" data-character="anime-boy"></canvas>
            <canvas class="preset-img" width="120" height="160" data-character="mascot"></canvas>
        </div>

        <div id="errorMessage"></div>
        <div id="loadingMessage"></div>
        
        <button id="startButton">ğŸš€ ARã‚’é–‹å§‹</button>
        
        <div id="info">
            ğŸ“± ã‚«ãƒ¡ãƒ©ã®ä½¿ç”¨ã‚’è¨±å¯ã—ã¦ãã ã•ã„<br>
            ğŸ’¡ æ˜ã‚‹ã„å ´æ‰€ã§ã”ä½¿ç”¨ãã ã•ã„<br>
            ğŸ”„ ãƒ‡ãƒã‚¤ã‚¹ã‚’å‹•ã‹ã—ã¦ARã‚’ä½“é¨“ã—ã¦ãã ã•ã„
        </div>
    </div>

    <div id="controls" class="hidden">
        <div class="control-group">
            <label>ğŸ“ é«˜ã•:</label>
            <input type="range" id="heightSlider" min="100" max="250" value="170" />
            <span id="heightValue" class="value-display">170cm</span>
        </div>
        <div class="control-group">
            <label>ğŸ“ è·é›¢:</label>
            <input type="range" id="distanceSlider" min="50" max="300" value="150" />
            <span id="distanceValue" class="value-display">1.5m</span>
        </div>
        <div class="control-group">
            <label>ğŸ”„ å›è»¢:</label>
            <input type="range" id="rotationSlider" min="0" max="360" value="0" />
            <span id="rotationValue" class="value-display">0Â°</span>
        </div>
        <div class="control-group">
            <button id="resetButton">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
            <button id="captureButton">ğŸ“¸ æ’®å½±</button>
            <button id="stopButton">â¹ï¸ çµ‚äº†</button>
        </div>
    </div>

    <script>
        class ARCharacterPanel {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.characterMesh = null;
                this.currentTexture = null;
                this.isARStarted = false;
                this.video = null;
                this.selectedPreset = null;
                
                // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
                window.addEventListener('error', (e) => {
                    console.error('Global error:', e.error);
                    this.showError('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + e.message);
                });

                this.initializeApp();
            }

            async initializeApp() {
                try {
                    this.showLoading('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åˆæœŸåŒ–ä¸­...');
                    await this.initializePresetImages();
                    this.bindEvents();
                    this.hideLoading();
                } catch (error) {
                    console.error('Initialization error:', error);
                    this.showError('åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                }
            }

            async initializePresetImages() {
                const presets = document.querySelectorAll('.preset-img');
                
                // ãƒ—ãƒªã‚»ãƒƒãƒˆç”»åƒã‚’ç”Ÿæˆ
                await Promise.all([
                    this.createAnimeGirl(presets[0]),
                    this.createAnimeBoy(presets[1]),
                    this.createMascot(presets[2])
                ]);

                // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
                presets[0].onclick = () => this.selectPreset(presets[0]);
                presets[1].onclick = () => this.selectPreset(presets[1]);
                presets[2].onclick = () => this.selectPreset(presets[2]);

                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé¸æŠ
                this.selectPreset(presets[0]);
            }

            selectPreset(canvas) {
                // å‰ã®é¸æŠã‚’è§£é™¤
                if (this.selectedPreset) {
                    this.selectedPreset.classList.remove('selected');
                }
                
                // æ–°ã—ã„é¸æŠ
                canvas.classList.add('selected');
                this.selectedPreset = canvas;
                
                // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æ›´æ–°
                this.loadCanvasTexture(canvas);
            }

            loadCanvasTexture(canvas) {
                try {
                    if (this.currentTexture) {
                        this.currentTexture.dispose();
                    }
                    this.currentTexture = new THREE.Texture(canvas);
                    this.currentTexture.needsUpdate = true;
                    
                    if (this.characterMesh) {
                        this.characterMesh.material.map = this.currentTexture;
                        this.characterMesh.material.needsUpdate = true;
                    }
                } catch (error) {
                    console.error('Texture loading error:', error);
                    this.showError('ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            }

            async createAnimeGirl(canvas) {
                return new Promise(resolve => {
                    const ctx = canvas.getContext('2d');
                    
                    // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯
                    const gradient = ctx.createLinearGradient(0, 0, 0, 160);
                    gradient.addColorStop(0, '#FFB6C1');
                    gradient.addColorStop(0.5, '#FF91A4');
                    gradient.addColorStop(1, '#FF69B4');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 120, 160);
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æç”»
                    this.drawCharacterBase(ctx, '#FFF8DC', '#8B4513', '#FF69B4');
                    
                    // é«ªã®æ¯›ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    ctx.fillStyle = '#A0522D';
                    ctx.fillRect(35, 25, 50, 10);
                    
                    setTimeout(resolve, 10);
                });
            }

            async createAnimeBoy(canvas) {
                return new Promise(resolve => {
                    const ctx = canvas.getContext('2d');
                    
                    const gradient = ctx.createLinearGradient(0, 0, 0, 160);
                    gradient.addColorStop(0, '#87CEEB');
                    gradient.addColorStop(0.5, '#5F9FD3');
                    gradient.addColorStop(1, '#4169E1');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 120, 160);
                    
                    this.drawCharacterBase(ctx, '#FFF8DC', '#2F4F4F', '#4169E1');
                    
                    setTimeout(resolve, 10);
                });
            }

            async createMascot(canvas) {
                return new Promise(resolve => {
                    const ctx = canvas.getContext('2d');
                    
                    const gradient = ctx.createLinearGradient(0, 0, 0, 160);
                    gradient.addColorStop(0, '#98FB98');
                    gradient.addColorStop(0.5, '#7FE57F');
                    gradient.addColorStop(1, '#32CD32');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 120, 160);
                    
                    // ãƒã‚¹ã‚³ãƒƒãƒˆé¢¨ã®ä¸¸ã„é¡”
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(60, 60, 35, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // ç›®
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(50, 50, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(70, 50, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // ç¬‘é¡”
                    ctx.beginPath();
                    ctx.arc(60, 65, 12, 0, Math.PI);
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#000';
                    ctx.stroke();
                    
                    // è€³
                    ctx.fillStyle = '#32CD32';
                    ctx.beginPath();
                    ctx.arc(40, 35, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(80, 35, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    setTimeout(resolve, 10);
                });
            }

            drawCharacterBase(ctx, skinColor, hairColor, accentColor) {
                // é¡”
                ctx.fillStyle = skinColor;
                ctx.fillRect(35, 30, 50, 60);
                
                // ç›®
                ctx.fillStyle = '#000';
                ctx.fillRect(45, 45, 10, 10);
                ctx.fillRect(65, 45, 10, 10);
                
                // ç›®ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                ctx.fillStyle = '#FFF';
                ctx.fillRect(47, 47, 4, 4);
                ctx.fillRect(67, 47, 4, 4);
                
                // å£
                ctx.fillStyle = accentColor;
                ctx.fillRect(55, 65, 10, 6);
                
                // é«ª
                ctx.fillStyle = hairColor;
                ctx.fillRect(30, 20, 60, 25);
                
                // ä½“
                ctx.fillStyle = accentColor;
                ctx.fillRect(40, 90, 40, 70);
            }

            bindEvents() {
                try {
                    document.getElementById('imageInput').addEventListener('change', (e) => this.handleImageUpload(e));
                    document.getElementById('startButton').addEventListener('click', () => this.startAR());
                    document.getElementById('stopButton').addEventListener('click', () => this.stopAR());
                    document.getElementById('resetButton').addEventListener('click', () => this.resetPosition());
                    document.getElementById('captureButton').addEventListener('click', () => this.captureScreen());
                    
                    document.getElementById('heightSlider').addEventListener('input', (e) => this.updateHeight(e.target.value));
                    document.getElementById('distanceSlider').addEventListener('input', (e) => this.updateDistance(e.target.value));
                    document.getElementById('rotationSlider').addEventListener('input', (e) => this.updateRotation(e.target.value));
                } catch (error) {
                    console.error('Event binding error:', error);
                    this.showError('ã‚¤ãƒ™ãƒ³ãƒˆã®è¨­å®šã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            }

            handleImageUpload(event) {
                const file = event.target.files[0];
                if (file) {
                    // å‰ã®é¸æŠã‚’è§£é™¤
                    if (this.selectedPreset) {
                        this.selectedPreset.classList.remove('selected');
                        this.selectedPreset = null;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.loadImageTexture(e.target.result);
                    };
                    reader.onerror = () => {
                        this.showError('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    };
                    reader.readAsDataURL(file);
                }
            }

            loadImageTexture(imageSrc) {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    try {
                        if (this.currentTexture) {
                            this.currentTexture.dispose();
                        }
                        this.currentTexture = new THREE.Texture(img);
                        this.currentTexture.needsUpdate = true;
                        
                        if (this.characterMesh) {
                            this.characterMesh.material.map = this.currentTexture;
                            this.characterMesh.material.needsUpdate = true;
                        }
                    } catch (error) {
                        console.error('Image texture error:', error);
                        this.showError('ç”»åƒãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è¨­å®šã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                };
                img.onerror = () => {
                    this.showError('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                };
                img.src = imageSrc;
            }

            async startAR() {
                try {
                    this.hideError();
                    this.showLoading('ã‚«ãƒ¡ãƒ©ã‚’åˆæœŸåŒ–ä¸­...');
                    
                    // ã‚«ãƒ¡ãƒ©ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å–å¾—
                    this.video = document.getElementById('video');
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            facingMode: 'environment',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });

                    this.video.srcObject = stream;
                    await new Promise(resolve => {
                        this.video.onloadedmetadata = resolve;
                    });

                    this.initializeThreeJS();
                    this.isARStarted = true;
                    
                    document.getElementById('ui').classList.add('hidden');
                    document.getElementById('controls').classList.remove('hidden');
                    this.hideLoading();
                    
                } catch (error) {
                    console.error('AR initialization failed:', error);
                    this.hideLoading();
                    this.showError('ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã§ã‚«ãƒ¡ãƒ©ã®ä½¿ç”¨ã‚’è¨±å¯ã—ã¦ãã ã•ã„ã€‚');
                }
            }

            initializeThreeJS() {
                try {
                    const canvas = document.getElementById('canvas');
                    
                    // Three.jsåŸºæœ¬è¨­å®š
                    this.scene = new THREE.Scene();
                    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    this.renderer = new THREE.WebGLRenderer({ 
                        canvas: canvas,
                        antialias: true, 
                        alpha: true 
                    });
                    
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setClearColor(0x000000, 0);

                    // ç…§æ˜ã‚’è¿½åŠ 
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                    this.scene.add(ambientLight);

                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                    directionalLight.position.set(1, 1, 1);
                    this.scene.add(directionalLight);

                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‘ãƒãƒ«ã‚’ä½œæˆ
                    this.createCharacterPanel();
                    
                    // ARçš„ãªå‹•ä½œã‚’è¨­å®š
                    this.setupARBehavior();
                    
                    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–‹å§‹
                    this.animate();
                } catch (error) {
                    console.error('Three.js initialization error:', error);
                    this.showError('3Dæç”»ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            }

            createCharacterPanel() {
                try {
                    let texture = this.currentTexture;
                    if (!texture && this.selectedPreset) {
                        texture = new THREE.Texture(this.selectedPreset);
                        texture.needsUpdate = true;
                        this.currentTexture = texture;
                    }

                    if (!texture) {
                        throw new Error('No texture available');
                    }

                    const aspectRatio = 0.6;
                    const height = 1.7;
                    const width = height * aspectRatio;

                    const geometry = new THREE.PlaneGeometry(width, height);
                    const material = new THREE.MeshLambertMaterial({
                        map: texture,
                        transparent: true,
                        alphaTest: 0.1,
                        side: THREE.DoubleSide
                    });

                    this.characterMesh = new THREE.Mesh(geometry, material);
                    this.characterMesh.position.set(0, height / 2, -1.5);
                    this.scene.add(this.characterMesh);
                } catch (error) {
                    console.error('Character panel creation error:', error);
                    this.showError('ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‘ãƒãƒ«ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            }

            setupARBehavior() {
                let lastOrientation = { alpha: 0, beta: 0, gamma: 0 };
                
                // ãƒ‡ãƒã‚¤ã‚¹ã®å‘ãã‚»ãƒ³ã‚µãƒ¼
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (event) => {
                        if (this.camera && this.isARStarted) {
                            const alpha = event.alpha || 0;
                            const beta = event.beta || 0;
                            const gamma = event.gamma || 0;

                            // æ»‘ã‚‰ã‹ãªå‹•ã
                            const smoothing = 0.1;
                            lastOrientation.alpha += (alpha - lastOrientation.alpha) * smoothing;
                            lastOrientation.beta += (beta - lastOrientation.beta) * smoothing;
                            lastOrientation.gamma += (gamma - lastOrientation.gamma) * smoothing;

                            this.camera.rotation.x = lastOrientation.beta * Math.PI / 180 * 0.5;
                            this.camera.rotation.y = lastOrientation.alpha * Math.PI / 180 * 0.5;
                            this.camera.rotation.z = lastOrientation.gamma * Math.PI / 180 * 0.3;
                        }
                    });
                }

                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
                let touchStart = { x: 0, y: 0 };
                let isDragging = false;

                const canvas = document.getElementById('canvas');

                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    isDragging = true;
                    touchStart.x = e.touches[0].clientX;
                    touchStart.y = e.touches[0].clientY;
                });

                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (isDragging && this.characterMesh && this.isARStarted) {
                        const deltaX = (e.touches[0].clientX - touchStart.x) * 0.005;
                        const deltaY = (e.touches[0].clientY - touchStart.y) * 0.005;

                        this.characterMesh.position.x += deltaX;
                        this.characterMesh.position.y -= deltaY;

                        touchStart.x = e.touches[0].clientX;
                        touchStart.y = e.touches[0].clientY;
                    }
                });

                canvas.addEventListener('touchend', () => {
                    isDragging = false;
                });

                // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆPCç”¨ï¼‰
                let mouseDown = false;
                canvas.addEventListener('mousedown', (e) => {
                    mouseDown = true;
                    touchStart.x = e.clientX;
                    touchStart.y = e.clientY;
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (mouseDown && this.characterMesh && this.isARStarted) {
                        const deltaX = (e.clientX - touchStart.x) * 0.005;
                        const deltaY = (e.clientY - touchStart.y) * 0.005;

                        this.characterMesh.position.x += deltaX;
                        this.characterMesh.position.y -= deltaY;

                        touchStart.x = e.clientX;
                        touchStart.y = e.clientY;
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    mouseDown = false;
                });
            }

            animate() {
                if (this.isARStarted && this.renderer && this.scene && this.camera) {
                    requestAnimationFrame(() => this.animate());
                    
                    try {
                        // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¾®ç´°ãªå‹•ã
                        if (this.characterMesh) {
                            this.characterMesh.rotation.y += Math.sin(Date.now() * 0.001) * 0.001;
                        }
                        
                        this.renderer.render(this.scene, this.camera);
                    } catch (error) {
                        console.error('Render error:', error);
                    }
                }
            }

            updateHeight(value) {
                document.getElementById('heightValue').textContent = value + 'cm';
                if (this.characterMesh) {
                    const height = parseFloat(value) / 100;
                    const scale = height / 1.7;
                    
                    this.characterMesh.scale.set(scale, scale, scale);
                    this.characterMesh.position.y = height / 2;
                }
            }

            updateDistance(value) {
                const distance = parseFloat(value) / 100;
                document.getElementById('distanceValue').textContent = distance.toFixed(1) + 'm';
                if (this.characterMesh) {
                    this.characterMesh.position.z = -distance;
                }
            }

            updateRotation(value) {
                document.getElementById('rotationValue').textContent = value + 'Â°';
                if (this.characterMesh) {
                    this.characterMesh.rotation.y = parseFloat(value) * Math.PI / 180;
                }
            }

            resetPosition() {
                if (this.characterMesh) {
                    this.characterMesh.position.set(0, 0.85, -1.5);
                    this.characterMesh.rotation.set(0, 0, 0);
                    this.characterMesh.scale.set(1, 1, 1);
                    
                    document.getElementById('heightSlider').value = 170;
                    document.getElementById('distanceSlider').value = 150;
                    document.getElementById('rotationSlider').value = 0;
                    this.updateHeight(170);
                    this.updateDistance(150);
                    this.updateRotation(0);
                }
            }

            captureScreen() {
                if (this.renderer) {
                    try {
                        const canvas = this.renderer.domElement;
                        const link = document.createElement('a');
                        link.download = 'ar-character-' + new Date().toISOString().slice(0, 19).replace(/:/g, '-') + '.png';
                        link.href = canvas.toDataURL('image/png');
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        this.showMessage('ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’ä¿å­˜ã—ã¾ã—ãŸ');
                    } catch (error) {
                        console.error('Capture error:', error);
                        this.showError('ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                }
            }

            stopAR() {
                try {
                    this.isARStarted = false;
                    
                    // ãƒ“ãƒ‡ã‚ªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åœæ­¢
                    if (this.video && this.video.srcObject) {
                        this.video.srcObject.getTracks().forEach(track => track.stop());
                    }

                    // Three.jsãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    if (this.renderer) {
                        this.renderer.dispose();
                    }
                    
                    if (this.currentTexture) {
                        this.currentTexture.dispose();
                    }

                    // UIã‚’æˆ»ã™
                    document.getElementById('ui').classList.remove('hidden');
                    document.getElementById('controls').classList.add('hidden');
                } catch (error) {
                    console.error('Stop AR error:', error);
                    this.showError('ARçµ‚äº†æ™‚ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
                }
            }

            showError(message) {
                const errorDiv = document.getElementById('errorMessage');
                errorDiv.textContent = 'âŒ ' + message;
                errorDiv.style.display = 'block';
                setTimeout(() => this.hideError(), 5000);
            }

            hideError() {
                document.getElementById('errorMessage').style.display = 'none';
            }

            showLoading(message) {
                const loadingDiv = document.getElementById('loadingMessage');
                loadingDiv.textContent = 'â³ ' + message;
                loadingDiv.style.display = 'block';
            }

            hideLoading() {
                document.getElementById('loadingMessage').style.display = 'none';
            }

            showMessage(message) {
                // ä¸€æ™‚çš„ã«ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤ºã‚’ä½¿ç”¨
                this.showLoading(message);
                setTimeout(() => this.hideLoading(), 2000);
            }
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        let arApp = null;
        window.addEventListener('load', () => {
            try {
                arApp = new ARCharacterPanel();
                window.arApp = arApp; // ãƒ‡ãƒãƒƒã‚°ç”¨
            } catch (error) {
                console.error('App initialization failed:', error);
                alert('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        });

        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
        window.addEventListener('resize', () => {
            if (arApp && arApp.camera && arApp.renderer) {
                try {
                    arApp.camera.aspect = window.innerWidth / window.innerHeight;
                    arApp.camera.updateProjectionMatrix();
                    arApp.renderer.setSize(window.innerWidth, window.innerHeight);
                } catch (error) {
                    console.error('Resize error:', error);
                }
            }
        });
    </script>
</body>
</html>